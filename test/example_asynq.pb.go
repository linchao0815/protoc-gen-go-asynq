// Code generated by protoc-gen-go-asynq. DO NOT EDIT.
// versions:
// protoc-gen-go-asynq v1.0.10

package example

import (
	context "context"
	json "encoding/json"
	asynq "github.com/hibiken/asynq"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

import "igspkg/logger"
import "igspkg/igstrace"
import "net/http"
import "strings"
import "go.opentelemetry.io/otel/propagation"
import "go.opentelemetry.io/otel/attribute"
import rkgrpcctx "github.com/rookie-ninja/rk-grpc/v2/middleware/context"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the asynq package it is being compiled against.
var _ = new(context.Context)
var _ = new(asynq.Task)
var _ = new(emptypb.Empty)
var _ = new(proto.Message)
var _ = new(json.InvalidUTF8Error)

type UserJobServer interface {
	CreateUser(context.Context, *CreateUserPayload) error
	UpdateUser(context.Context, *UpdateUserPayload) error
}

func RegisterUserJobServer(mux *asynq.ServeMux, srv UserJobServer) {
	mux.HandleFunc("user:create", _User_CreateUser_Job_Handler(srv))
	mux.HandleFunc("user:update", _User_UpdateUser_Job_Handler(srv))
}

func _User_CreateUser_Job_Handler(srv UserJobServer) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		var in CreateUserPayload
		t := &igstrace.TaskPaylod{
			In: &in,
		}
		if err := json.Unmarshal(task.Payload(), &t); err != nil {
			return logger.GetSkip(1).Errorln(task.Type(), logger.NewRequest(t), logger.NewWhy(err))
		}
		//ctx, beforeCtx := igstrace.Before(ctx, "asynq", task.Type())
		//scp := rkgrpcmid.GetServerContextPayload(ctx)

		//scp["req"] = t
		logger.MetricCounterInc("asynq_Handler")
		ctx, span := igstrace.NewSpan(ctx, "CreateUser")
		err := srv.CreateUser(ctx, t.In.(*CreateUserPayload))
		/*
			if err != nil{
				err=logger.GetSkip(1).Errorln(task.Type(),logger.NewRequest(t),logger.NewWhy(err))
			}else{
				logger.GetSkip(1).Info(task.Type(),logger.NewRequest(t))
			}
		*/
		//igstrace.After(ctx, beforeCtx, err)
		span.SetAttributes(attribute.String("req", igstrace.ToMarshal(t)))
		igstrace.EndSpan(span, err == nil)
		return err
	}
}

func _User_UpdateUser_Job_Handler(srv UserJobServer) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		var in UpdateUserPayload
		t := &igstrace.TaskPaylod{
			In: &in,
		}
		if err := json.Unmarshal(task.Payload(), &t); err != nil {
			return logger.GetSkip(1).Errorln(task.Type(), logger.NewRequest(t), logger.NewWhy(err))
		}
		//ctx, beforeCtx := igstrace.Before(ctx, "asynq", task.Type())
		//scp := rkgrpcmid.GetServerContextPayload(ctx)

		//scp["req"] = t
		logger.MetricCounterInc("asynq_Handler")
		ctx, span := igstrace.NewSpan(ctx, "UpdateUser")
		err := srv.UpdateUser(ctx, t.In.(*UpdateUserPayload))
		/*
			if err != nil{
				err=logger.GetSkip(1).Errorln(task.Type(),logger.NewRequest(t),logger.NewWhy(err))
			}else{
				logger.GetSkip(1).Info(task.Type(),logger.NewRequest(t))
			}
		*/
		//igstrace.After(ctx, beforeCtx, err)
		span.SetAttributes(attribute.String("req", igstrace.ToMarshal(t)))
		igstrace.EndSpan(span, err == nil)
		return err
	}
}

type UserSvcJob struct{}

var UserJob UserSvcJob

func (j *UserSvcJob) CreateUser(ctx context.Context, in *CreateUserPayload, opts ...asynq.Option) (*asynq.Task, *http.Header, error) {
	// get trace metadata
	header := http.Header{}
	pg := rkgrpcctx.GetTracerPropagator(ctx)
	if pg != nil {
		pg.Inject(ctx, propagation.HeaderCarrier(header))
	} else {
		logger.GetSkip(1).Errorln("CreateUser GetTracerPropagator=nil")
	}
	t := &igstrace.TaskPaylod{
		In:          in,
		TraceHeader: header,
	}
	payload, err := json.Marshal(t)
	if err != nil {
		return nil, nil, err
	}
	//logger.GetSkip(1).Info("CreateUser", logger.NewRequest(string(payload)))

	task := asynq.NewTask("user:create", payload, opts...)
	return task, &header, nil
}

func (j *UserSvcJob) UpdateUser(ctx context.Context, in *UpdateUserPayload, opts ...asynq.Option) (*asynq.Task, *http.Header, error) {
	// get trace metadata
	header := http.Header{}
	pg := rkgrpcctx.GetTracerPropagator(ctx)
	if pg != nil {
		pg.Inject(ctx, propagation.HeaderCarrier(header))
	} else {
		logger.GetSkip(1).Errorln("UpdateUser GetTracerPropagator=nil")
	}
	t := &igstrace.TaskPaylod{
		In:          in,
		TraceHeader: header,
	}
	payload, err := json.Marshal(t)
	if err != nil {
		return nil, nil, err
	}
	//logger.GetSkip(1).Info("UpdateUser", logger.NewRequest(string(payload)))

	task := asynq.NewTask("user:update", payload, opts...)
	return task, &header, nil
}

type UserJobClient interface {
	CreateUser(ctx context.Context, req *CreateUserPayload, opts ...asynq.Option) (info *asynq.TaskInfo, err error)
	UpdateUser(ctx context.Context, req *UpdateUserPayload, opts ...asynq.Option) (info *asynq.TaskInfo, err error)
}

type UserJobClientImpl struct {
	cc *asynq.Client
}

func NewUserJobClient(client *asynq.Client) UserJobClient {
	return &UserJobClientImpl{client}
}

func (c *UserJobClientImpl) CreateUser(ctx context.Context, in *CreateUserPayload, opts ...asynq.Option) (*asynq.TaskInfo, error) {
	task, header, err := UserJob.CreateUser(ctx, in, opts...)
	if err != nil {
		return nil, logger.GetSkip(1).Errorln("UserJob.CreateUser", logger.NewRequest(in), logger.NewWhy(err))
	}
	//logger.GetSkip(1).Info("UserJob.CreateUser", logger.NewRequest(in))
	logger.MetricCounterInc("asynq_Enqueue")
	info, err := c.cc.Enqueue(task)
	if err != nil {
		return nil, logger.GetSkip(1).Errorln("UserJob.CreateUser Enqueue", logger.NewRequest(in), logger.NewWhy(err))
	}
	// 把 Trace 信息，存入 Metadata，以 Header 的形式返回给 httpclient
	for k, v := range *header {
		rkgrpcctx.AddHeaderToClient(ctx, k, strings.Join(v, ","))
	}
	return info, nil
}

func (c *UserJobClientImpl) UpdateUser(ctx context.Context, in *UpdateUserPayload, opts ...asynq.Option) (*asynq.TaskInfo, error) {
	task, header, err := UserJob.UpdateUser(ctx, in, opts...)
	if err != nil {
		return nil, logger.GetSkip(1).Errorln("UserJob.UpdateUser", logger.NewRequest(in), logger.NewWhy(err))
	}
	//logger.GetSkip(1).Info("UserJob.UpdateUser", logger.NewRequest(in))
	logger.MetricCounterInc("asynq_Enqueue")
	info, err := c.cc.Enqueue(task)
	if err != nil {
		return nil, logger.GetSkip(1).Errorln("UserJob.UpdateUser Enqueue", logger.NewRequest(in), logger.NewWhy(err))
	}
	// 把 Trace 信息，存入 Metadata，以 Header 的形式返回给 httpclient
	for k, v := range *header {
		rkgrpcctx.AddHeaderToClient(ctx, k, strings.Join(v, ","))
	}
	return info, nil
}
